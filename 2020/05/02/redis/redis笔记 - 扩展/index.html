<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis学习笔记 | Unique Craftsman</title><meta name="description" content="Redis的初学"><meta name="keywords" content="tag1,tag2,tag3"><meta name="author" content="小兔子乖乖"><meta name="copyright" content="小兔子乖乖"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="www.dengjing520.cn/2020/05/02/redis/redis%E7%AC%94%E8%AE%B0%20-%20%E6%89%A9%E5%B1%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Redis学习笔记"><meta property="og:url" content="www.dengjing520.cn/2020/05/02/redis/redis%E7%AC%94%E8%AE%B0%20-%20%E6%89%A9%E5%B1%95/"><meta property="og:site_name" content="Unique Craftsman"><meta property="og:description" content="Redis的初学"><meta property="og:image" content="www.dengjing520.cn/img/post/post4.jpg"><meta property="article:published_time" content="2020-05-02T07:30:16.000Z"><meta property="article:modified_time" content="2020-09-09T05:26:09.357Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: {"appId":"ZSC04LOBCX","apiKey":"34b7ba6cc72a096588854b65468c7d74","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-09-09 13:26:09'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><script src="https://cdn.jsdelivr.net/gh/yremp/yremp-js@1.5/sakura.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Redis%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">一、Redis版本历史介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis2-6"><span class="toc-number">1.1.</span> <span class="toc-text">1.Redis2.6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis2-8"><span class="toc-number">1.2.</span> <span class="toc-text">2.Redis2.8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis3-0"><span class="toc-number">1.3.</span> <span class="toc-text">3.Redis3.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis3-2"><span class="toc-number">1.4.</span> <span class="toc-text">4.Redis3.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Redis4-0"><span class="toc-number">1.5.</span> <span class="toc-text">5.Redis4.0</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redis5-0%E7%89%88%E6%98%AFRedis%E4%BA%A7%E5%93%81%E7%9A%84%E9%87%8D%E5%A4%A7%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83"><span class="toc-number">1.6.</span> <span class="toc-text">6.Redis5.0版是Redis产品的重大版本发布</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%89%A9%E5%B1%95"><span class="toc-number">2.</span> <span class="toc-text">二、数据结构扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-string%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1.string类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.hash类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-list%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">3.list类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-set%E7%B1%BB%E5%9E%8B-%E3%80%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%BB%E9%87%8D%E3%80%91"><span class="toc-number">2.4.</span> <span class="toc-text">4.set类型 【分布式去重】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-zset%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.5.</span> <span class="toc-text">5.zset类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-GEO%EF%BC%88%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D%EF%BC%89%E9%9C%80%E8%A6%81%E8%BE%83%E9%AB%98%E7%9A%84redis%E7%89%88%E6%9C%AC%E5%92%8Cjdis%E7%89%88%E6%9C%AC%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">6.GEO（地理信息定位）需要较高的redis版本和jdis版本（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-bitmaps%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.7.</span> <span class="toc-text">7.bitmaps类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.</span> <span class="toc-text">三、Redis的常用使用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Redis%E4%B8%A4%E5%A4%A7%E4%BC%98%E7%82%B9"><span class="toc-number">4.</span> <span class="toc-text">四、Redis两大优点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%AB%98%E6%80%A7%E8%83%BD%E3%80%90%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E9%AB%98%E3%80%91"><span class="toc-number">4.1.</span> <span class="toc-text">1.高性能【查询效率高】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%AB%98%E5%B9%B6%E5%8F%91%E3%80%90%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%91"><span class="toc-number">4.2.</span> <span class="toc-text">2.高并发【可以接受更多的请求】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">4.3.</span> <span class="toc-text">3.为什么要用缓存?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98%E4%B9%8B%E5%90%8E%E4%BC%9A%E6%9C%89%E5%95%A5%E4%B8%8D%E8%89%AF%E7%9A%84%E5%90%8E%E6%9E%9C"><span class="toc-number">5.</span> <span class="toc-text">五、使用缓存之后会有啥不良的后果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">5.1.</span> <span class="toc-text">1.定义：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">（1）缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">5.1.2.</span> <span class="toc-text">（2）缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">5.1.3.</span> <span class="toc-text">（3）缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A"><span class="toc-number">5.2.</span> <span class="toc-text">2.解决方案：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">（1）缓存穿透：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">（2）缓存击穿：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">（3）缓存雪崩：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81BIO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">6.</span> <span class="toc-text">六、BIO、NIO、AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BIO-%E9%98%BB%E5%A1%9EIO"><span class="toc-number">6.1.</span> <span class="toc-text">1.BIO:阻塞IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NIO-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">6.2.</span> <span class="toc-text">2.NIO:非阻塞IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AIO-%E5%BC%82%E6%AD%A5IO"><span class="toc-number">6.3.</span> <span class="toc-text">3.AIO:异步IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IO%E5%A4%9A%E8%B7%AF%E8%BD%AC%E6%8E%A5"><span class="toc-number">6.4.</span> <span class="toc-text">4.IO多路转接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="toc-number">6.5.</span> <span class="toc-text">5.信号驱动IO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E6%95%88%E7%8E%87%E9%AB%98"><span class="toc-number">7.</span> <span class="toc-text">七、Redis为什么查询效率高</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BA%AF%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.</span> <span class="toc-text">1.纯内存操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.2.</span> <span class="toc-text">2.非阻塞的IO多路复用机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8F%8D%E8%80%8C%E9%81%BF%E5%85%8D%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A2%91%E7%B9%81%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98-%EF%BC%88%E6%AF%94%E8%BE%83%E7%89%B5%E5%BC%BA%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">3.单线程反而避免了多线程的频繁上下文切换问题 （比较牵强）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81redis%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">8.</span> <span class="toc-text">八、redis的过期策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="toc-number">8.1.</span> <span class="toc-text">1.定期删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">8.2.</span> <span class="toc-text">2.惰性删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Redis%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">九、Redis的内存淘汰机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81Redis%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">10.</span> <span class="toc-text">十、Redis的高可用集群</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/post/post4.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unique Craftsman</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Redis学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-05-02T07:30:16.000Z" title="发表于 2020-05-02 15:30:16">2020-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-09T05:26:09.357Z" title="更新于 2020-09-09 13:26:09">2020-09-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Redis/">Redis</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="一、Redis版本历史介绍"><a href="#一、Redis版本历史介绍" class="headerlink" title="一、Redis版本历史介绍"></a>一、Redis版本历史介绍</h1><p>​        [原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34206560/article/details/90902924]">https://blog.csdn.net/qq_34206560/article/details/90902924]</a><br>​        Redis借鉴了Linux操作系统对于版本号的命名规则：版本号第二位如果是奇数，则为非稳定版本（例如2.7、2.9、3.1），如果是偶数，则为稳定版本（例如2.6、2.8、3.0、3.2）。当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。所以我们在生产环境通常选取偶数版本的Redis，如果对于某些新的特性想提前了解和使用，可以选择最新的奇数版本。</p>
<h2 id="1-Redis2-6"><a href="#1-Redis2-6" class="headerlink" title="1.Redis2.6"></a>1.Redis2.6</h2><pre><code class="java">Redis2.6在2012年正式发布，经历了17个版本，到2.6.17版本，相比于
Redis2.4，主要特性如下：
1）服务端支持Lua脚本。【安全校验】
2）两个新的位图命令：bitcount和bitop。【BitMap原理：https://www.jianshu.com/p/bf9dbbc147ed】</code></pre>
<h2 id="2-Redis2-8"><a href="#2-Redis2-8" class="headerlink" title="2.Redis2.8"></a>2.Redis2.8</h2><pre><code class="java">Redis2.8在2013年11月22日正式发布，经历了24个版本，到2.8.24版本，
相比于Redis2.6，主要特性如下：
1）添加部分主从复制的功能，在一定程度上降低了由于网络问题，造成频繁全量复制生成RDB对系统造成的压力。
2）发布订阅添加了pubsub命令。【仿消息队列】</code></pre>
<h2 id="3-Redis3-0"><a href="#3-Redis3-0" class="headerlink" title="3.Redis3.0"></a>3.Redis3.0</h2><pre><code class="java">Redis3.0在2015年4月1日正式发布，相比于Redis2.8主要特性如下：
注意
Redis3.0最大的改动就是添加Redis的分布式实现Redis Cluster，填补了
Redis官方没有分布式实现的空白。Redis Cluster经历了4年才正式发布也是
有原因的，具体可以参考Redis Cluster的开发日志
（http://antirez.com/news/79）。
1）Redis Cluster：Redis的官方分布式实现。【分布式】
2）lru算法大幅提升。【淘汰策略】
3）Redis日志小做调整：日志中会反应当前实例的角色（master或者slave）。</code></pre>
<p>任何东西的都不是单机，最少是两份</p>
<h2 id="4-Redis3-2"><a href="#4-Redis3-2" class="headerlink" title="4.Redis3.2"></a>4.Redis3.2</h2><pre><code class="java">Redis3.2在2016年5月6日正式发布，相比于Redis3.0主要特征如下：
1）添加GEO相关功能。【redis的GEO实战：https://www.jianshu.com/p/81bf3baa64e5】
2）新的List编码类型：quicklist
3）新的RDB格式，但是仍然兼容旧的RDB。
4）加速RDB的加载速度。
5）cluster nodes命令得到加速。</code></pre>
<h2 id="5-Redis4-0"><a href="#5-Redis4-0" class="headerlink" title="5.Redis4.0"></a>5.Redis4.0</h2><pre><code class="java">可能出乎很多人的意料，Redis3.2之后的版本是4.0，而不是3.4、3.6、3.8。一般这种重大版本号的升级也意味着软件或者工具本身发生了重大变革，Redis发布了4.0-RC2，下面列出Redis4.0的新特性：
1）提供了模块系统，方便第三方开发者拓展Redis的功能，更多模块详见：http://redismodules.com。
    a.新数据结构，如：
    rejson 提供了对原生 JSON 格式支持，允许对 JSON 数据内的值进行获取与修改
    Redis Graph 添加了对图数据库的支持等等

    b.对现有数据结构功能的扩展，如：
    rxkeys 提供了按正则表达式批量获取与删除条目的功能
    rxhashes 提供了在 Hash 中改变现有条目的值并返回原值的原子操做
    rxlists 提供了 7 个新的列表操作方法。

2）PSYNC2.0：优化了之前版本中，主从节点切换必然引起全量复制的问题。
3）提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势。【很牛逼】
4）提供memory命令，实现对内存更为全面的监控统计。【很牛逼】
5）Redis Cluster兼容NAT和Docker。</code></pre>
<h2 id="6-Redis5-0版是Redis产品的重大版本发布"><a href="#6-Redis5-0版是Redis产品的重大版本发布" class="headerlink" title="6.Redis5.0版是Redis产品的重大版本发布"></a>6.Redis5.0版是Redis产品的重大版本发布</h2><pre><code class="java">1)新的流数据类型(Stream data type) https://redis.io/topics/streams-intro
2)新的 Redis 模块 API：定时器、集群和字典 API(Timers, Cluster and Dictionary APIs)</code></pre>
<h1 id="二、数据结构扩展"><a href="#二、数据结构扩展" class="headerlink" title="二、数据结构扩展"></a>二、数据结构扩展</h1><h2 id="1-string类型"><a href="#1-string类型" class="headerlink" title="1.string类型"></a>1.string类型</h2><p>​    场景：</p>
<p>​    缓存：普通的set命令</p>
<p>​    计数器：incr key 原子性自增操作</p>
<p>​    分布式锁：setnx 命令</p>
<p>​    分布式session ：普通的set命令</p>
<pre><code class="java">API：
        *get key   获取key对应的value
        *set key value   设置key-value
        *del key    删除key-value
        ***incr key    key自增1，如果key不存在，自增后get(key)=1    原子性操作
        ***decr key    key自减1，如果key不存在，自减后get(key)=-1
        *incrby key k    key自增k，如果key不存在，自增后get(key)=k
        *decrby key k    key自减k，如果key不存在，自减后get(key)=-k
        *set key value    不管key是否存在，都设置
        ***setnx key value    key不存在，才设置                      分布式锁    
        *set key value xx    key存在，才设置
        *mget key1 key2 key3    批量获取key，原子操作
        *mset key1 value1 key2 value2    批量设置key-value
        *getset key newvalue    set key newvalue并返回旧的value
        *append key value    将value追加到旧的value</code></pre>
<p>​    java代码中</p>
<p>​    1.乐观锁</p>
<pre><code class="java">    非常乐观的锁，认为任何时候都不会发生线程安全问题    CAS CompareAndSwap  比较和交换 

    使用场景： ConcurrentHashMap 【JDK 1.8  CAS+synchronized  （casTabAt）】
    CAS（Compare And Swap）比较并交换。
    CAS算法的实现过程：它包含3个参数CAS(V,E,N)。V表示要更新的变量(内存值)，E表示预期值(旧的)，N表示新值。
    当且仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。
    最后，CAS返回当前V的真实值。(乐观锁的原理)
    CAS会导致“ABA问题”。解决方案：使用AtomicStampedReference（原子标记参考）控制变量的版本来解决CAS的问题  
    version 1.0 2  version 2.0  3   version 3.0  2  

    CAS算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。
    比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，
    这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</code></pre>
<p>​    2.悲观锁：</p>
<pre><code class="java">    锁：lock 锁：
    ReentrantLock（再入锁）
    位于java.util.concurrent.locks包。
    能够实现比synchronized更细粒度的控制，如控制fairness（公平性）。
    调用lock()后，必须调用unlock()释放锁。
    性能未必比synchronized高。


    synchronized：
    synchronized的四种状态
    （1）无锁 CAS

        自旋锁
        许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得。
        通过让线程执行忙循环等待锁的释放，不让出CPU。
        缺点：若锁被其它线程长时间占用，会带来许多性能上的开销。    
    （2）偏向锁
        优点：没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距。
        缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗。
        使用场景：只有一个线程访问同步块或者同步方法的场景。
        核心思想：在锁对象的对象头中有一个ThreadId字段，当第一个线程访问锁时，如果该锁没有被其他线程访问过，即ThreadId字段为空，
        那么JVM让其持有偏向锁，并将ThreadId字段的值设置为该线程的ID。
        当下一次获取锁时，会判断当前线程的ID是否与锁对象的ThreadId一致。如果一致那么该线程不会再重复获取锁，从而提高了程序的运行效率。

    （3）轻量级锁
        优点：竞争的线程不会阻塞，提高了响应速度。
        缺点：若线程长时间抢不到锁，自旋会消耗CPU性能。
        使用场景：线程交替执行同步块或者同步方法的场景。
    （4）重量级锁
        优点：线程竞争不使用自旋，不会消耗CPU。
        缺点：线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗。
        使用场景：追求吞吐量，同步块或者同步方法执行时间较长的场景。</code></pre>
<pre><code class="java">
ReentrantLock和synchronized的区别
    ReentrantLock显示的获得、释放锁，synchronized隐式获得释放锁
    ReentrantLock是API级别的，synchronized是JVM级别的
    ReentrantLock可以实现公平锁
    Lock是一个接口，而synchronized是Java中的关键字
    synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；
    Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。 </code></pre>
<h2 id="2-hash类型"><a href="#2-hash类型" class="headerlink" title="2.hash类型"></a>2.hash类型</h2><pre><code class="java">哈希键值结构：key   field value  

    类似map的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是这个对象没嵌套其他的对象）给缓存在redis里，然后每次读写缓存的时候，可以就操作hash里的某个字段</code></pre>
<p>场景：用户信息  、购物车 HashMap&lt;key，HashMap&lt;key,value&gt;&gt;</p>
<pre><code class="java">key=carid   key=userId 
value=&#123;
“id”: 150,
“name”: “zhangsan”,
“age”: 20
&#125;</code></pre>
<pre><code class="java">特点：Mapmap    filed不能相同，value可以相同
    API：
        *hget key field    获取hash key对应的field的value
        *hset key field value    设置hash key对应field的value
        *hdel key field    删除hash key对应field的value
        *hexists key field    判断hash key是否有field
        *hlen key    获取hash key field的数量
        *hmget key field1 field2 ... fieldN    批量获取hash key的一批field对应的值
        *hmset key field1 value1 field2 value2 ... fieldN valueN    批量设置hash key的一批field value
        *hgetall key    返回hash key对应所有的field和value
        *hvals key    返回hash key对应所有filed的value
        *hkeys key    返回hash key对应所有field</code></pre>
<h2 id="3-list类型"><a href="#3-list类型" class="headerlink" title="3.list类型"></a>3.list类型</h2><p>​    结构：key  elements<br>​    场景：微博TimeLine    微博，某个大v的粉丝，就可以以list的格式放在redis里去缓存</p>
<pre><code class="java">    key=某大v

    value=[zhangsan, lisi, wangwu]

    比如可以通过list存储一些列表型的数据结构，类似粉丝列表了、文章的评论列表了之类的东西</code></pre>
<pre><code>特点：有序、可以重复、左右两边可以插入弹出
API：
    *rpush key value1 value2 ... valueN    从列表右端插入值
    *lpush key value1 value2 ... valueN    从列表左端插入值
    *linsert key before|after value newValue    在list指定的值前|后插入newValue
    *lpop key    从列表左侧弹出一个item
    *rpop    从列表右侧弹出一个item
    *lrem key count value    根据count值，从列表中删除所有value相等的项
                （1）count&gt;0，从左到右，删除最多count个value相等的项
                （2）count&lt;0，从右到左，删除最多Math.abs(count)个value相等的项
                （3）count=0，删除所有value相等的项
    *ltrim key start end    按照索引范围修剪列表
    *lrange key start end(包含end)    获取列表指定索引范围所有item（可以做简单分页）
    *lindex key index    获取列表指定索引的item
    *llen key    获取列表长度
    *lset key index newValue    设置列表指定索引值为newValue
    *blpop key timeout    lpop阻塞版本，timeout是阻塞超时时间
    *brpop key timeout    rpop阻塞版本，timeout是阻塞超时时间（如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。）

扩展应用：
    1、LRUSH + LPOP = Stack  栈：先进后出
    2、LPUSH + RPOP = Queue  队列：先进先出
    3、LPUSH + BRPOP = Message Queue  消息队列 

左边进，右边出，可以做消息队列  【排队】</code></pre>
<h2 id="4-set类型-【分布式去重】"><a href="#4-set类型-【分布式去重】" class="headerlink" title="4.set类型 【分布式去重】"></a>4.set类型 【分布式去重】</h2><p>​    结构：key values<br>​    特点：无序、无重复、支持集合间操作<br>​        </p>
<pre><code>    直接基于set将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于jvm内存里的HashSet进行去重，但是如果你的某个系统部署在        多台机器上呢？
    得基于redis进行全局的set去重

    可以基于set玩儿交集、并集、差集的操作，比如交集，可以把两个人的粉丝列表整一个交集，看看俩人的共同好友是谁？对吧

    把两个大v的粉丝都放在两个set中，对两个set做交集
</code></pre>
<p>应用：抽奖系统、给用户添加标签、给标签添加用户、共同关注</p>
<pre><code class="ja">API：
    *sadd key element    向集合key添加element，如果element已经存在，添加失败
    *srem key element     将集合key中的element移除掉
    *scard key    计算集合大小
    *sismember key element    判断element是否在集合中
    *srandmember key count    从集合中随机挑选count个元素
    *spop key    从集合中随机弹出一个元素
    *smembers key    获取集合所有元素
    *sdiff key1 key2    差集
    *sinter key1 key2    交集
    *sunion key1 key2    并集</code></pre>
<h2 id="5-zset类型"><a href="#5-zset类型" class="headerlink" title="5.zset类型"></a>5.zset类型</h2><p>​    结构：key    scores values<br>​    特点：无重复元素、有序<br>​    应用：排行榜</p>
<pre><code class="java">    API：        
        *zadd key score element（可以是多对）    添加score和element
        *zrem key element（可以是多个）    删除元素
        *zscore key element    返回元素的分数
        *zincrby key increScore element    增加或减少元素的分数
        *zcard key    返回元素的总个数
        *zrange key start end    返回指定索引范围内的升序元素【分值】
        *zrangebyscore key minScore maxScore    返回指定分数范围内的升序元素【分值】
        *zremrangebyrank key start end    删除指定排名内的升序元素
        *zremrangebyscore key minScore maxScore    删除指定分数内的升序元素</code></pre>
<h2 id="6-GEO（地理信息定位）需要较高的redis版本和jdis版本（了解）"><a href="#6-GEO（地理信息定位）需要较高的redis版本和jdis版本（了解）" class="headerlink" title="6.GEO（地理信息定位）需要较高的redis版本和jdis版本（了解）"></a>6.GEO（地理信息定位）需要较高的redis版本和jdis版本（了解）</h2><p>​    应用：存储经纬度、计算两地距离、范围计算（酒店、餐馆距离)   </p>
<p>​    <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/81bf3baa64e5">https://www.jianshu.com/p/81bf3baa64e5</a> </p>
<pre><code class="java">    API：
        *geoadd key longitude latitude member    增加地理位置信息
            例：geoadd city 116.28 39.55 beijing
        *geopos key member    获取地理位置信息
            例：geopos city beijing
        *geodist key member1 member2 [unit]    获取两个地理位置的距离
            unit：m(米)、km(千米)、mi(英里)、ft(尺)
            例：geodist city tianjin beijing</code></pre>
<h2 id="7-bitmaps类型"><a href="#7-bitmaps类型" class="headerlink" title="7.bitmaps类型"></a>7.bitmaps类型</h2><p>​    详细链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a5ebb807ca31">https://www.jianshu.com/p/a5ebb807ca31</a> </p>
<h1 id="三、Redis的常用使用场景"><a href="#三、Redis的常用使用场景" class="headerlink" title="三、Redis的常用使用场景"></a>三、<strong>Redis的常用使用场景</strong></h1><pre><code class="java">1.缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；

2.排行榜，在使用传统的关系型数据库（mysql oracle 等）来做这个事儿，非常的麻烦，而利用Redis的SortSet(有序集合)数据结构能够简单的搞定；

3.计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
可能使用到限速器的接口：设计到钱的接口，短信发送接口  6分
限流：谷歌有个框架，叫做漏斗桶

4.好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；

5.简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；【键空间通知】
    Redis实现消息队列:
    因为好多人去用redis做消息队列,作者基于redis的核心代码，另外实现了一个消息队列disque,redis内置消息队列
    八卦：https://www.zhihu.com/question/20795043

6.Session共享，以java为例，默认Session是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。

7.一些频繁被访问的数据，经常被访问的数据如果放在关系型数据库，每次查询的开销都会很大，而放在redis中，因为redis 是放在内存中的可以很高效的访问</code></pre>
<h1 id="四、Redis两大优点"><a href="#四、Redis两大优点" class="headerlink" title="四、Redis两大优点"></a>四、Redis两大优点</h1><h2 id="1-高性能【查询效率高】"><a href="#1-高性能【查询效率高】" class="headerlink" title="1.高性能【查询效率高】"></a>1.高性能【查询效率高】</h2><pre><code class="java">假设这么个场景，你有个操作，一个请求过来，吭哧吭哧你各种乱七八糟操作mysql，半天查出来一个结果，耗时600ms。但是这个结果可能接下来几个小时都不会变了，或者变了也可以不用立即反馈给用户。那么此时咋办？

缓存啊，折腾600ms查出来的结果，扔缓存里，一个key对应一个value，下次再有人查，别走mysql折腾600ms了。直接从缓存里，通过一个key查出来一个value，2ms搞定。性能提升300倍。

这就是所谓的高性能。

就是把你一些复杂操作耗时查出来的结果，如果确定后面不咋变了，然后但是马上还有很多读请求，那么直接结果放缓存，后面直接读缓存就好了。
</code></pre>
<h2 id="2-高并发【可以接受更多的请求】"><a href="#2-高并发【可以接受更多的请求】" class="headerlink" title="2.高并发【可以接受更多的请求】"></a>2.高并发【可以接受更多的请求】</h2><pre><code class="jav">mysql这么重的数据库，压根儿设计不是让你玩儿高并发的，虽然也可以玩儿，但是天然支持不好。mysql单机支撑到2000qps也开始容易报警了。

所以要是你有个系统，高峰期一秒钟过来的请求有1万，那一个mysql单机绝对会死掉。你这个时候就只能上缓存，把很多数据放缓存，别放mysql。缓存功能简单，说白了就是key-value式操作，单机支撑的并发量轻松一秒几万十几万，支撑高并发so easy。单机承载并发量是mysql单机的几十倍。
</code></pre>
<h2 id="3-为什么要用缓存"><a href="#3-为什么要用缓存" class="headerlink" title="3.为什么要用缓存?"></a>3.为什么要用缓存?</h2><pre><code class="java">a. 高性能
b. 高并发
</code></pre>
<h1 id="五、使用缓存之后会有啥不良的后果"><a href="#五、使用缓存之后会有啥不良的后果" class="headerlink" title="五、使用缓存之后会有啥不良的后果"></a>五、使用缓存之后会有啥不良的后果</h1><h2 id="1-定义："><a href="#1-定义：" class="headerlink" title="1.定义："></a>1.定义：</h2><h3 id="（1）缓存穿透"><a href="#（1）缓存穿透" class="headerlink" title="（1）缓存穿透"></a>（1）缓存穿透</h3><pre><code class="java">就是黑客恶意持续向服务器发起对【不存在服务器中数据的请求】。客户先在Redis中查询，查询不到后去数据库中查询。
</code></pre>
<p>​    打个比方，你是个很有钱的人，开满了百度云，腾讯视频各种杂七杂八的会员，但是你就是没有bilibili的会员，然后你把这些账号和密码发布到一个你自己做的<strong>网站</strong>上，然后你有一个朋友每过十秒钟就查询你的网站，发现你的网站<strong>没有bilibili的会员</strong>后打电话向你要。你就相当于是个数据库，网站就是Redis。这就是<strong>缓存穿透</strong>。</p>
<h3 id="（2）缓存击穿"><a href="#（2）缓存击穿" class="headerlink" title="（2）缓存击穿"></a>（2）缓存击穿</h3><pre><code class="java">就是一个很热门的数据，突然失效，大量请求到服务器数据库中.</code></pre>
<p>大家都喜欢看腾讯视频上的《双世宠妃2》，但是你的会员突然<strong>到期了</strong>，大家在你的网站上看不到腾讯视频的账号，纷纷打电话向你询问，这就是**缓存击穿 **</p>
<h3 id="（3）缓存雪崩"><a href="#（3）缓存雪崩" class="headerlink" title="（3）缓存雪崩"></a>（3）缓存雪崩</h3><pre><code class="java">就是大量数据同一时间失效。</code></pre>
<p>你的各种会员突然<strong>同一时间都失效了</strong>，那这就是<strong>缓存雪崩</strong>了。</p>
<h2 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a>2.解决方案：</h2><h3 id="（1）缓存穿透："><a href="#（1）缓存穿透：" class="headerlink" title="（1）缓存穿透："></a>（1）缓存穿透：</h3><p>​    1.接口层增加校验，对传参进行个校验，比如说我们的id是从1开始的，那么id&lt;=0的直接拦截；</p>
<p>​    2.缓存中取不到的数据，在数据库中也没有取到，这时可以将key-value对写为key-null，设置过期时间为60s，这样可以防止攻击用户反复用同一个id暴力攻击。</p>
<p>​    3.布隆过滤器（本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在” ）。</p>
<h3 id="（2）缓存击穿："><a href="#（2）缓存击穿：" class="headerlink" title="（2）缓存击穿："></a>（2）缓存击穿：</h3><p>​    1. 最好的办法就是设置热点数据永不过期，拿到刚才的比方里，那就是你买腾讯一个永久会员</p>
<h3 id="（3）缓存雪崩："><a href="#（3）缓存雪崩：" class="headerlink" title="（3）缓存雪崩："></a>（3）缓存雪崩：</h3><p>​    1.缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。 60s加一个随机的数</p>
<p>​    2.如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</p>
<h1 id="六、BIO、NIO、AIO"><a href="#六、BIO、NIO、AIO" class="headerlink" title="六、BIO、NIO、AIO"></a>六、BIO、NIO、AIO</h1><pre><code class="java">在网络环境下，通俗的讲，将IO分为两步：
1.等；       基于阻塞的io
2.数据搬迁。 基于缓冲区的io</code></pre>
<h2 id="1-BIO-阻塞IO"><a href="#1-BIO-阻塞IO" class="headerlink" title="1.BIO:阻塞IO"></a>1.BIO:阻塞IO</h2><p>blocking I/O</p>
<pre><code class="java">    A拿着一支鱼竿在河边钓鱼，并且一直在鱼竿前等，在等的时候不做其他的事情，十分专心。只有鱼上钩的时，才结束掉等的动作，把鱼钓上来。【面向流】</code></pre>
<h2 id="2-NIO-非阻塞IO"><a href="#2-NIO-非阻塞IO" class="headerlink" title="2.NIO:非阻塞IO"></a>2.NIO:非阻塞IO</h2><p>​    noblocking I/O</p>
<pre><code class="java">B也在河边钓鱼，但是B不想将自己的所有时间都花费在钓鱼上，在等鱼上钩这个时间段中，B也在做其他的事情（一会看看书，一会读读报纸，一会又去看其他人的钓鱼等），但B在做这些事情的时候，每隔一个固定的时间检查鱼是否上钩。一旦检查到有鱼上钩，就停下手中的事情，把鱼钓上来。【面向缓冲区】</code></pre>
<h2 id="3-AIO-异步IO"><a href="#3-AIO-异步IO" class="headerlink" title="3.AIO:异步IO"></a>3.AIO:异步IO</h2><p>​    asynchronous I/O</p>
<pre><code class="java">E也想钓鱼，但E有事情，于是他雇来了F，让F帮他等待鱼上钩，一旦有鱼上钩，F就打电话给E，E就会将鱼钓上去。</code></pre>
<h2 id="4-IO多路转接"><a href="#4-IO多路转接" class="headerlink" title="4.IO多路转接"></a>4.IO多路转接</h2><p>​    I/O multiplexing</p>
<pre><code class="java">D同样也在河边钓鱼，但是D生活水平比较好，D拿了很多的鱼竿，一次性有很多鱼竿在等，D不断的查看每个鱼竿是否有鱼上钩。增加了效率，减少了等待的时间。</code></pre>
<h2 id="5-信号驱动IO"><a href="#5-信号驱动IO" class="headerlink" title="5.信号驱动IO"></a>5.信号驱动IO</h2><p>​    signal blocking I/O</p>
<pre><code class="ja">C也在河边钓鱼，但与A、B不同的是，C比较聪明，他给鱼竿上挂一个铃铛，当有鱼上钩的时候，这个铃铛就会被碰响，C就会将鱼钓上来。
</code></pre>
<h1 id="七、Redis为什么查询效率高"><a href="#七、Redis为什么查询效率高" class="headerlink" title="七、Redis为什么查询效率高"></a>七、Redis为什么查询效率高</h1><h2 id="1-纯内存操作"><a href="#1-纯内存操作" class="headerlink" title="1.纯内存操作"></a>1.纯内存操作</h2><p>（1）计算机存储的介质：</p>
<pre><code class="java">Register（寄存器【CPU内部高速缓存区】）
&gt;L1 Cache（一级缓存【CPU流水线】）
&gt;L2 Cache（二级缓存【CPU流水线】）
&gt;Main Memory（内存）
&gt;Local Disk（本地磁盘）
&gt;Remote Disk（远程磁盘）</code></pre>
<p>（2）<strong>文件事件处理器</strong>是基于内存的</p>
<h2 id="2-非阻塞的IO多路复用机制"><a href="#2-非阻塞的IO多路复用机制" class="headerlink" title="2.非阻塞的IO多路复用机制"></a>2.非阻塞的IO多路复用机制</h2><p><img src="/02/redis/redis%E7%AC%94%E8%AE%B0%20-%20%E6%89%A9%E5%B1%95/03_redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png"></p>
<h2 id="3-单线程反而避免了多线程的频繁上下文切换问题-（比较牵强）"><a href="#3-单线程反而避免了多线程的频繁上下文切换问题-（比较牵强）" class="headerlink" title="3.单线程反而避免了多线程的频繁上下文切换问题 （比较牵强）"></a>3.单线程反而避免了多线程的频繁上下文切换问题 （比较牵强）</h2><pre><code class="java">    Redis性能瓶颈不在CPU上，在内存上面，如果使用多线程的话，考虑到数据安全问题，可能会加锁，加锁的话，CPU性能会提高，并且，效率也不一定快，单线程足够了</code></pre>
<h1 id="八、redis的过期策略"><a href="#八、redis的过期策略" class="headerlink" title="八、redis的过期策略"></a>八、redis的过期策略</h1><p>redis采用了 <strong>“定期删除+惰性删除”</strong> 的过期策略。 </p>
<h2 id="1-定期删除"><a href="#1-定期删除" class="headerlink" title="1.定期删除"></a>1.定期删除</h2><pre><code class="java">（1）原理：
    定期删除指的是redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。

（2）为什么会选择一部分，而不是全部：
    因为如果这是redis里面有大量的key都设置了过期时间，那么如果全部去检测一遍，CPU负载就会很高，会浪费大量的时间在检测上面，甚至直接导致redis挂掉。所有只会抽取一部分而不会全部检查。

（3）出现问题：
    这样的话就会出现大量的已经过期的key并没有被删除，这就是 为什么有时候大量的key明明已经过了失效时间，但是redis的内存还是被大量占用的原因 ，为了解决这个问题，就需要 惰性删除 这个策略了。
</code></pre>
<h2 id="2-惰性删除"><a href="#2-惰性删除" class="headerlink" title="2.惰性删除"></a>2.惰性删除</h2><pre><code class="java">（1）原理：
    惰性删除不在是redis去主动删除，而是在你要获取某个key 的时候，redis会先去检测一下这个key是否已经过期，如果没有过期则返回给你，如果已经过期了，那么redis会删除这个key，不会返回给你。

（2）这样两种策略就保证了 过期的key最终一定会被删除掉 ，但是这只是保证了最终一定会被删除，要是定时删除漏掉了大量过期的key，而且我们也没有及时的去访问这些key，那么这些key不就不会被删除了吗？不就会一直占着我们的内存吗?这样不还是会导致redis内存耗尽吗？

（3）由于存在这样的问题，所以redis引入了 内存淘汰机制 来解决。
</code></pre>
<h1 id="九、Redis的内存淘汰机制"><a href="#九、Redis的内存淘汰机制" class="headerlink" title="九、Redis的内存淘汰机制"></a>九、Redis的内存淘汰机制</h1><pre><code class="java">当内存使用达到最大值时，redis使用的清楚策略。有以下几种可以选择：volatile-lru

lru：计算最少使用的数据

1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了
2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key
3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的key给干掉啊【危险不要用】
4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key
5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

  1）volatile-lru   利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used ) 
  2）allkeys-lru   利用LRU算法移除任何key 
  3）volatile-random 移除设置过过期时间的随机key 
  4）allkeys-random  移除随机ke
  5）volatile-ttl   移除即将过期的key(minor TTL) 
  6）noeviction  noeviction   不移除任何key，只是返回一个写错误 ，默认选项
</code></pre>
<pre><code class="java">但是实际上这还是有问题的，如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？

答案是：走内存淘汰机制。

（2）内存淘汰

如果redis的内存占用过多的时候，此时会进行内存淘汰，有如下一些策略：

redis 10个key，现在已经满了，redis需要删除掉5个key

1个key，最近1分钟被查询了100次
1个key，最近10分钟被查询了50次
1个key，最近1个小时被查询了1次


百度，问题啊，网上鱼龙混杂

如果百度一些api操作，入门的知识，ok的，随便找一个博客都可以

一些高级别的，redis单线程模型

很简单，你写的数据太多，内存满了，或者触发了什么条件，redis lru，自动给你清理掉了一些最近很少使用的数据

（3）要不你手写一个LRU算法？

我确实有时会问这个，因为有些候选人如果确实过五关斩六将，前面的问题都答的很好，那么其实让他写一下LRU算法，可以考察一下编码功底

你可以现场手写最原始的LRU算法，那个代码量太大了，我觉得不太现实

public class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123;

private final int CACHE_SIZE;

    // 这里就是传递进来最多能缓存多少数据
    public LRUCache(int cacheSize) &#123;
        super((int) Math.ceil(cacheSize / 0.75) + 1, 0.75f, true); // 这块就是设置一个hashmap的初始大小，同时最后一个true指的是让linkedhashmap按照访问顺序来进行排序，最近访问的放在头，最老访问的就在尾
        CACHE_SIZE = cacheSize;
    &#125;

    @Override
    protected boolean removeEldestEntry(Map.Entry eldest) &#123;
        return size() &gt; CACHE_SIZE; // 这个意思就是说当map中的数据量大于指定的缓存个数的时候，就自动删除最老的数据
    &#125;

&#125;

我给你看上面的代码，是告诉你最起码你也得写出来上面那种代码，不求自己纯手工从底层开始打造出自己的LRU，但是起码知道如何利用已有的jdk数据结构实现一个java版的LRU
</code></pre>
<h1 id="十、Redis的高可用集群"><a href="#十、Redis的高可用集群" class="headerlink" title="十、Redis的高可用集群"></a>十、Redis的高可用集群</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59ff4a11d8e1">https://www.jianshu.com/p/59ff4a11d8e1</a> </p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小兔子乖乖</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/www.dengjing520.cn/2020/05/02/redis/redis%E7%AC%94%E8%AE%B0%20-%20%E6%89%A9%E5%B1%95/">www.dengjing520.cn/2020/05/02/redis/redis%E7%AC%94%E8%AE%B0%20-%20%E6%89%A9%E5%B1%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="www.dengjing520.cn" target="_blank">Unique Craftsman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tag1/">tag1</a><a class="post-meta__tags" href="/tags/tag2/">tag2</a><a class="post-meta__tags" href="/tags/tag3/">tag3</a></div><div class="post_share"><div class="social-share" data-image="/img/post/post4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/pay/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/pay/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/02/sql/sql%E4%BC%98%E5%8C%96/"><img class="prev-cover" src="/img/post/post8.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">简单的SQL优化</div></div></a></div><div class="next-post pull-right"><a href="/2019/12/07/server/Tomcat%E4%BC%98%E5%8C%96%20/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">少许Tomcat基本优化点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/06/02/sql/sql优化/" title="简单的SQL优化"><img class="cover" src="/img/post/post8.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">简单的SQL优化</div></div></a></div><div><a href="/2019/12/07/server/Tomcat优化 /" title="少许Tomcat基本优化点"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-07</div><div class="title">少许Tomcat基本优化点</div></div></a></div><div><a href="/2019/12/02/小的知识点/" title="编程日记"><img class="cover" src="/img/post/post.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">编程日记</div></div></a></div><div><a href="/2019/12/02/sql/01.事务/" title="数据库事务"><img class="cover" src="/img/post/post2.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">数据库事务</div></div></a></div><div><a href="/2019/12/02/life/live/写给自己的总结/" title="重新开始用心记录每一个遇到的问题"><img class="cover" src="/img/post/post7.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">重新开始用心记录每一个遇到的问题</div></div></a></div><div><a href="/2019/12/02/life/live/愚蠢日记/" title="愚蠢日记"><img class="cover" src="/img/post/post1.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">愚蠢日记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(/img/post/post4.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小兔子乖乖</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/algolia.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script></div></body></html>