<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>数据库习题练习整理 | Unique Craftsman</title><meta name="description" content="每日一sql练习下来的成果"><meta name="keywords" content="tag1,tag2,tag3"><meta name="author" content="小兔子乖乖"><meta name="copyright" content="小兔子乖乖"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon1.png"><link rel="canonical" href="www.dengjing520.cn/2019/11/02/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%A0%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="数据库习题练习整理"><meta property="og:url" content="www.dengjing520.cn/2019/11/02/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%A0%E9%A2%98/"><meta property="og:site_name" content="Unique Craftsman"><meta property="og:description" content="每日一sql练习下来的成果"><meta property="og:image" content="www.dengjing520.cn/img/post/post5.jpg"><meta property="article:published_time" content="2019-11-02T07:30:16.000Z"><meta property="article:modified_time" content="2020-09-09T05:22:40.737Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.5/dist/instantsearch.min.js" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.1.1',
  algolia: {"appId":"ZSC04LOBCX","apiKey":"34b7ba6cc72a096588854b65468c7d74","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isSidebar: true,
  postUpdate: '2020-09-09 13:22:40'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="APlayer.min.css"><div id="aplayer"></div><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js" async></script><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><script src="https://cdn.jsdelivr.net/gh/yremp/yremp-js@1.5/sakura.js"></script><meta name="generator" content="Hexo 5.1.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">17</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">4</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%A0%E9%A2%98%E7%BB%83%E4%B9%A0%E6%95%B4%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">数据库习题练习整理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">基本查询格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9Asql%E9%A2%98%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%AD%A5%E9%AA%A4%EF%BC%9A-WWAL"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">做sql题的四大步骤： (WWAL)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%AF%95%E9%A2%98%E7%9B%AE"><span class="toc-number">1.0.1.</span> <span class="toc-text">考试题目</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/post/post5.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Unique Craftsman</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">数据库习题练习整理</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2019-11-02T07:30:16.000Z" title="发表于 2019-11-02 15:30:16">2019-11-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-09T05:22:40.737Z" title="更新于 2020-09-09 13:22:40">2020-09-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="数据库习题练习整理"><a href="#数据库习题练习整理" class="headerlink" title="数据库习题练习整理"></a>数据库习题练习整理</h1><h4 id="基本查询格式"><a href="#基本查询格式" class="headerlink" title="基本查询格式"></a>基本查询格式</h4><pre><code class="sql">SELECT   
     id,group_concat(username), --查询的条件
     count(*) AS totalUsers, -- 聚合函数
     Avg(age) AS  avg_age 
FROM    
     cms_user -- 查询的表
WHERE   
     id&gt;=1 --  条件
GROUP BY sex    --- 分组
Having count(*)&gt;=2  --  组内判断
ORDER BY age DESC --  排序
Limit 0,2  ;    --  限制查询的条数</code></pre>
<h4 id="做sql题的四大步骤：-WWAL"><a href="#做sql题的四大步骤：-WWAL" class="headerlink" title="做sql题的四大步骤： (WWAL)"></a>做sql题的四大步骤： (WWAL)</h4><pre><code>   *  1.查询的是什么字段，是什么（What）
   *  2.查询的字段从哪里来（Where）
   *  3.表与表之间的关联关系，通过那个字段相关联（And）
   *  4.有哪些限制条件：是否要一些条件判断，是否重复，是否需要组内筛选，是否需要排序，是否需要限制条数（Limit）</code></pre>
<p>1.查找最晚入职员工的所有信息</p>
<pre><code class="sql">select *from employees 
where  hire_date=(select emp_no,max(hire_date) from  employees)

select e.*
from employees e,(select emp_no,max(hire_date) from  employees) c
where e.emp_no=c.emp_no

`SELECT * FROM employees ORDER BY hire_date DESC LIMIT ``0``,``1`

select emp_no,birth_date,first_name,last_name,gender,max(hire_date) from employees

</code></pre>
<p>2.查找入职员工时间排名倒数第三的员工所有信息</p>
<pre><code class="sql">select*
from employees
where hire_date=
(select distinct hire_date from employees order by hire_date desc limit 2,1)

select distinct * from employees order by hire_date desc limit 2,1
以后查找相关倒数的思路
1.首先解读这个排名，按照题目意思应该是按照入职的先后时间去排，入职最早的时间最小，应该在最上面，那么升序，

2.取倒数第三，首先第一次查询要倒序，取顺数第三的，
            然后取出来的就是排好的

3.若不加distinct去重，那么按照日期倒序，limit 2,1（从倒数第2行开始，取一条数据）的查询结果为 5-23
加了distinct去重，会按入职日期进行分组，多个相同入职日期会分为一组，这样limit 2,1的结果即为 5-21。加了distinct去重，会按入职日期进行分组，多个相同入职日期会分为一组，这样limit 2,1的结果即为 5-21。

</code></pre>
<p>3.查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no       <code>dept_manager</code>     salaries</p>
<pre><code class="sql">SELECT
   s.*,d.dept_no
FROM salaries s
join dept_manager d on d.emp_no=s.emp_no
where s.to_date=&#39;9999-01-01&#39; and d.to_date=&#39;9999-01-01&#39;

SELECT 
     s.*, d.dept_no 
FROM salaries s , dept_manager d
WHERE s.to_date=&#39;9999-01-01&#39;
AND d.to_date=&#39;9999-01-01&#39;
AND s.emp_no = d.emp_no;
</code></pre>
<p>4.查找所有已经分配部门的员工的last_name和first_name</p>
<pre><code class="sql">显示内连接
SELECT DISTINCT
e.last_name,e.first_name
FROM employees e
JOIN dept_emp d ON e.emp_no=d.emp_no

隐式内连接
SELECT DISTINCT e.last_name,e.first_name 
from employees e,dept_emp d WHERE e.emp_no=d.emp_no

这种题目需要用到两个表交集部分，使用内连接的方式。
</code></pre>
<p>5.查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工</p>
<pre><code class="sql">使用左外连接查询对没有分配具体部门的员工进行查询
select 
e.last_name,e.first_name,d.dept_no
from employees e
left join dept_emp d on e.emp_no=d.emp_no

注意：
INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。
LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。
</code></pre>
<p>6.查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</p>
<pre><code class="sql">员工入职时候的薪水情况：MIN(from_date) 
按照emp_no进行逆序：desc
SELECT emp_no,salary 
FROM salaries 
GROUP BY emp_no HAVING MIN(from_date)  
ORDER BY emp_no desc

1.查询
SELECT emp_no,salary,MIN(from_date) FROM salaries GROUP BY emp_no

select s.emp_no,s.salary
from (SELECT emp_no,salary,MIN(from_date) FROM salaries GROUP BY emp_no) s
order by s.emp_no desc</code></pre>
<p>7.查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</p>
<pre><code class="sql">涨幅15次，那么排除第一次变动，那么统计次数应该是16次
因为这个题目的工资涨幅次数存在争议所以有下面：
1.工资的涨幅不考虑为0的请况，即工资出现两次相同的也算是有涨幅，只是涨幅次数是0
select
emp_no,count(salary) t
from salaries
group by emp_no having t&gt;16

select
emp_no,count(emp_no) t
from salaries
group by emp_no having t&gt;15 

2.工资的涨幅，还是要有涨幅的相同的不算
select
s.emp_no,count(s.salary) t
from (select distinct emp_no,salary from salaries) s
group by s.emp_no having t&gt;16 

select emp_no,count(distinct salary) t 
from salaries group by emp_no  having t&gt;16
</code></pre>
<p>8.找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</p>
<pre><code class="sql">楼上都是用distinct，但是大表一般用distinct效率不高，大数据量的时候都禁止用distinct，建议用group by解决重复问题。
1.我使用的是distinct去重
select distinct salary 
from salaries where to_date=&#39;9999-01-01&#39;
order by salary desc


2.group by 也可以去重，还有以上的效率问题,group by
select salary
from salaries
where to_date=&#39;9999-01-01&#39;
group by salary
order by salary  desc

两者区别：
   1.去重：数据去重，去重之后数据丢失，只留排序的第一条,全局扫描，并且全部遍历去重，数据量小的时候效率高
   2.group by:数据分组 分组之后数据不会丢失 可把组中人数进行聚合统计，先创建索引，然后才进行分组



</code></pre>
<p>9.获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</p>
<pre><code class="sql">from后面跟一个表，这个表示用内连接关联查询出来的一张表
使用两次对当前时间查询
select d.dept_no, s.emp_no,s.salary
from salaries s
join dept_manager d on s.emp_no=d.emp_no
where d.to_date=&#39;9999-01-01&#39; 
and s.to_date=&#39;9999-01-01&#39;

select d.dept_no, s.emp_no,s.salary
from salaries s
join dept_manager d on s.emp_no=d.emp_no
and s.to_date=&#39;9999-01-01&#39; 

</code></pre>
<p>10、获取所有非manager的员工emp_no</p>
<pre><code class="sql">not in的使用
select emp_no
from employees
where emp_no not in 
(SELECT emp_no FROM dept_manager)

使用内连接
select emp_no
from employees
where emp_no not in 
(select e.emp_no from employees e,dept_manager d where e.emp_no=d.emp_no )

使用左外连接
select emp_no from 
(select* from employees e left 
join dept_manager d on e.emp_no=d.emp_no )
where dept_no is null

这里需要使用where进行拼接，使用and没用
select e.emp_no 
from employees e left 
join dept_manager d on e.emp_no=d.emp_no
where dept_no is null
</code></pre>
<p>11.获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</p>
<pre><code class="sql">1.首先查询的是普通的员工编号emp_no
  和manager对应的manager_no，其实是部门经理表的编号emp_no
2.两表关联想到了，join on ，这里需要根据他们的部门关联
3.如果当前的manager是自己的话结果不显示（如果员工编号和经理编号相同，则不显示，因为经理即是员工又是经理，就不要显示在普通员工表了）
4.where对当前的员工和经理进行筛选

select e.emp_no,m.emp_no as manager_no
from dept_emp e
join dept_manager m on e.dept_no=m.dept_no
WHERE e.to_date=&#39;9999-01-01&#39; and m.to_date=&#39;9999-01-01&#39;
and e.emp_no&lt;&gt;m.emp_no


</code></pre>
<p>12.获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary</p>
<pre><code class="sql">WWAL使用
 W:  dept_no, emp_no以及其对应的salary
 W:  salaries s,dept_emp d 
 A:  s.emp_no=d.emp_no
 L:  GROUP BY d.dept_no,MAX(s.salary)，and s.to_date=&#39;9999-01-01&#39; and d.to_date=&#39;9999-01-01&#39;

1.这是当前最大工资不重复的，即部门中最大工资只有一个的情况
SELECT d.dept_no, s.emp_no,MAX(s.salary)
from salaries s,dept_emp d 
WHERE s.emp_no=d.emp_no and s.to_date=&#39;9999-01-01&#39;
and d.to_date=&#39;9999-01-01&#39;
GROUP BY d.dept_no


SELECT d.dept_no, s.emp_no,MAX(s.salary)
from salaries s join dept_emp d on
s.emp_no=d.emp_no and s.to_date=&#39;9999-01-01&#39;
and d.to_date=&#39;9999-01-01&#39;
GROUP BY d.dept_no

这种方式貌似最复杂，但是最规范,貌似慢了一点
SELECT d.dept_no, s.emp_no,MAX(s.salary)
from salaries s 
join dept_emp d on s.emp_no=d.emp_no 
where s.to_date=&#39;9999-01-01&#39;and d.to_date=&#39;9999-01-01&#39;
GROUP BY d.dept_no


select 
 d.dept_no,
 d.emp_no,
 s.salary
from dept_emp d join salaries s using(emp_no)
where d.to_date=&#39;9999-01-01&#39; and s.to_date=&#39;9999-01-01&#39;
group by d.dept_no having s.salary=max(s.salary)

2.因为MAX(s.salary)只有能显示最大的一条所以，上面的这种方法不好，因为一个部门下当前时间的员工最大工资不一定只有一个
SELECT de.dept_no, de.emp_no,MAX(s.salary)
from salaries s 
join dept_emp de on s.emp_no=de.emp_no 
and s.to_date=&#39;9999-01-01&#39;and de.to_date=&#39;9999-01-01&#39;
where s.salary = (select max(s2.salary)
              from dept_emp de2 join salaries s2
              on de2.emp_no = s2.emp_no
              and de2.to_date = &#39;9999-01-01&#39;
              and s2.to_date = &#39;9999-01-01&#39;
              where de2.dept_no = de.dept_no
              group by de2.dept_no)
order by s.salary


</code></pre>
<p>13.从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</p>
<pre><code class="sql">select title,count(emp_no) t
from titles
group by title having c&gt;=2


从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。
注意对于重复的title进行忽略。
select title ,count(distinct emp_no) t
from titles
group by title having c&gt;=2

</code></pre>
<p>14.查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列</p>
<pre><code class="sql">数据库判断奇偶数：
select*from employees
where last_name&lt;&gt;&#39;Mary&#39; and emp_no%2=1
order by hire_date desc
</code></pre>
<p>15.统计出当前各个title类型对应的员工当前（to_date=’9999-01-01’）薪水对应的平均工资。结果给出title以及平均工资avg。</p>
<pre><code class="sql">
select t.title,avg(s.salary)
from titles t join  salaries s on s.emp_no=t.emp_no 
where s.to_date=&#39;9999-01-01&#39;and s.to_date=&#39;9999-01-01&#39; 
group by t.title;

select t.title,avg(s.salary)
from titles t , salaries s 
where s.emp_no=t.emp_no and s.to_date=&#39;9999-01-01&#39;and s.to_date=&#39;9999-01-01&#39; 
group by t.title;
</code></pre>
<p>16.获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary</p>
<pre><code class="java">
select emp_no,salary
from salaries
where to_date=&#39;9999-01-01&#39;
group by emp_no
order by salary desc
limit 1,1

</code></pre>
<p>17.查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by</p>
<pre><code class="sql">SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_name 
FROM employees AS e INNER JOIN salaries AS s 
ON e.emp_no = s.emp_no
WHERE s.to_date = &#39;9999-01-01&#39;
AND s.salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date = &#39;9999-01-01&#39;)
</code></pre>
<p>18.查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工</p>
<pre><code class="sql">select e.last_name,e.fristname, de.dept_name
from employees e 
left join dept_emp d on e.emp_no=d.emp_no
left join department de on d.dept_no=de.dept_no


</code></pre>
<p>19.查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth</p>
<pre><code class="sql">select max(salary)-min(salary) as growth
from salaries where emp_no = 10001;
</code></pre>
<p>20.查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序</p>
<pre><code class="java">1.这是我的答案，按照工资最高点和最低点来计算涨幅情况
select e.emp_no ,max(s.salary)-min(s.salary) growth
from employees e 
LEFT join  salaries s on e.emp_no=s.emp_no
group by e.emp_no
order by growth 

2.根据答案分析，工资的涨幅情况应该是当前的工资情况和入职时候的薪资进行工资涨幅分析，所以需要用到
因为内连接有两种所以产生了下面两种
第一种根据两次左外连接和一次内连接  ，第二种是根据外连接并列
第一个外连接查出：当前的薪资情况这里要采用外连接，因为部分员工为null
第二个外连接查出：根据入职时间的关联查出薪资情况
最好使用内连接关联两个表
这是我的答案，不考虑为空的情况，我多加了分组
SELECT     sCurrent.emp_no ,(sCurrent.salary-sStart.salary) growth
from 
(SELECT s.emp_no,s.salary from employees e 
left join salaries s on e.emp_no=s.emp_no where s.to_date=&#39;9999-01-01&#39;)
as sCurrent 
join 
(SELECT s.emp_no,s.salary from employees e 
left join salaries s on e.emp_no=s.emp_no where hire_date=s.from_date)
as sStart
on sCurrent.emp_no=sStart.emp_no
GROUP BY sCurrent.emp_no
ORDER BY growth 

</code></pre>
<p>21.统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum</p>
<pre><code class="sql">
select 
   t.dept_no,de.dept_name,count(DISTINCT t.salary ) sum
from 
(select d.dept_no,s.salary from salaries s,dept_emp d where s.emp_no =d.emp_no) t, departments de 
where t.dept_no=de.dept_no
GROUP BY de.dept_no
</code></pre>
<p>22.对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列</p>
<pre><code class="sql">//没弄懂 rank怎么确定

SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rank
FROM salaries AS s1, salaries AS s2
WHERE s1.to_date = &#39;9999-01-01&#39;  AND s2.to_date = &#39;9999-01-01&#39; AND s1.salary &lt;= s2.salary
GROUP BY s1.emp_no
ORDER BY s1.salary DESC, s1.emp_no ASC

</code></pre>
<ol start="23">
<li>给出每个员工每年薪水涨幅超过5000的员工编号emp_no、薪水变更开始日期from_date以及薪水涨幅值salary_growth，并按照salary_growth逆序排列。提示：在sqlite中获取datetime时间对应的年份函数为strftime(‘%Y’, to_date)</li>
</ol>
<pre><code class="sql">1.难点在于如何确定当前的年限，因为一年内员工涨薪大于5000，一张表中多个员工，多个from_date  to_date,所以只能先确定开始的年限
2.假设s1是涨薪水前的表，s2是涨薪水后的表，因为每个员工涨薪水的时间不全固定，有可能一年涨两次，有可能两年涨一次，所以每年薪水的涨幅，应该理解为两条薪水记录的from_date相同或to_date相同。

SELECT s2.emp_no, s2.from_date, (s2.salary - s1.salary) AS salary_growth
FROM salaries AS s1, salaries AS s2
WHERE s1.emp_no = s2.emp_no 
AND salary_growth &gt; 5000
AND (strftime(&quot;%Y&quot;,s2.to_date) - strftime(&quot;%Y&quot;,s1.to_date) = 1 OR strftime(&quot;%Y&quot;,s2.from_date) - strftime(&quot;%Y&quot;,s1.from_date) = 1 )
ORDER BY salary_growth DESC

</code></pre>
<ol start="24">
<li>获取所有非manager员工当前的薪水情况，给出dept_no、emp_no以及salary ，当前表示to_date=’9999-01-01’</li>
</ol>
<pre><code class="sql">not in 后面不能有空字段的条件，下面是链接
https://blog.csdn.net/qiudechao1/article/details/82791585

select  de.dept_no dept_no ,de.emp_no emp_no ,salary 
from dept_emp de, salaries s
where s.to_date=&#39;9999-01-01&#39; and s.emp_no not in
(select emp_no from dept_manager where emp_no is not null)
and de.emp_no= s.emp_no and de.to_date=&#39;9999-01-01&#39;;
</code></pre>
<ol start="25">
<li>获取员工其当前的薪水比其manager当前薪水还高的相关信息，当前表示to_date=’9999-01-01’,<br>结果第一列给出员工的emp_no，<br>第二列给出其manager的manager_no，<br>第三列给出该员工当前的薪水emp_salary,<br>第四列给该员工对应的manager当前的薪水manager_salary</li>
</ol>
<pre><code class="sql">1、先用INNER JOIN连接salaries和demp_emp，建立当前所有员工的工资记录sem
2、再用INNER JOIN连接salaries和demp_manager，建立当前所有员工的工资记录sdm
3、最后用限制条件sem.dept_no = sdm.dept_no AND sem.salary &gt; sdm.salary找出同一部门中工资比经理高的员工，并根据题意依次输出emp_no、manager_no、emp_salary、manager_salary


select et.emp_no,mt.manager_no,empemp_salary,manager_salary
from (select  de.emp_no ,s.salary empemp_salary,de.dept_no ded from dept_emp de join salaries s on de.emp_no=s.emp_no where s.to_date=&#39;9999-01-01&#39;) et,
(SELECT dm.emp_no manager_no,s.salary manager_salary,dm.dept_no dmd from dept_manager dm join salaries s on dm.emp_no=s.emp_no where s.to_date=&#39;9999-01-01&#39;) mt
where ded=dmd and empemp_salary&gt;empemp_salary



-- 获取员工其当前的薪水比其manager当前薪水还高的相关信息
-- 获取当前员工的薪水
select  de.emp_no ,s.salary empemp_salary,de.dept_no ded from dept_emp de join salaries s on de.emp_no=s.emp_no where s.to_date=&#39;9999-01-01&#39;
-- 获取当前manager
SELECT dm.emp_no manager_no,s.salary manager_salary,dm.dept_no dmd from dept_manager dm join salaries s on dm.emp_no=s.emp_no where s.to_date=&#39;9999-01-01&#39;
</code></pre>
<ol start="26">
<li>汇总各个部门当前员工的title类型的分配数目，结果给出部门编号dept_no、dept_name、其当前员工所有的title以及该类型title对应的数目count</li>
</ol>
<pre><code class="sql">
SELECT de.dept_no,d.dept_name,t.title,count(t.title) 
FROM departments d 
INNER JOIN dept_emp de 
ON d.dept_no=de.dept_no AND de.to_date=&#39;9999-01-01&#39;
INNER JOIN titles t 
ON de.emp_no=t.emp_no AND t.to_date=&#39;9999-01-01&#39;
GROUP BY d.dept_no,t.title


</code></pre>
<p>27.查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p>
<pre><code class="sql">案例如下：
select 
(length(&#39;10,A,B&#39;)-length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)))/length(&#39;,&#39;) as 总次数

select 
(length(&#39;10,A,B&#39;)-length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)))/length(&#39;,&#39;) as &#39;总次数&#39;

select 
(length(&#39;10,A,B&#39;)-length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)))/length(&#39;,&#39;) as &quot;总次数&quot;






2.先用replace函数将原串中出现的子串用空串替换，再用原串长度减去替换后字符串的长度，最后除以子串的长度
select 
length(&#39;10,A,B&#39;)-length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)) as cnt

select 
length(&#39;10,A,B&#39;) -length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)) as cnt

升级下
为什么要除以这个符号的个数？
select 
(length(&#39;10,A,B&#39;)-length(replace(&#39;10,A,B&#39;,&quot;,&quot;,&quot;&quot;)))/length(&#39;,&#39;) as cnt
看了这里你就懂了
SELECT (length(&quot;10,,A,,B&quot;)-length(replace(&quot;10,,A,,B&quot;,&quot;,,&quot;,&quot;&quot;)))/length(&quot;,,&quot;) as cnt</code></pre>
<p>28.将employees表的所有员工的last_name和first_name拼接起来作为Name，中间以一个空格区分</p>
<pre><code class="java">1.mysql函数考察，字符串连接
使用concat   
  select concat(&#39;11&#39;,&#39;22&#39;,&#39;33&#39;);   112233
  select concat(&#39;11&#39;,&#39; &#39;,&#39;33&#39;);   11 33
使用concat_ws  
  select concat_ws(&#39; &#39;,&#39;11&#39;,&#39;22&#39;);   11 22

扩展：    
MySQL中group_concat函数（去重并连接）

完整的语法如下：
group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator &#39;分隔符&#39;])
以id分组，把name字段的值打印在一行，逗号分隔(默认)
select id,group_concat(name) from aa group by id;

MySQL中repeat()函数
用来复制字符串,如下&#39;ab&#39;表示要复制的字符串，2表示复制的份数
select repeat(&#39;ab&#39;,2);     abab    
</code></pre>
<p>29.编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary）</p>
<p>（如果不存在第二高的薪水，那么查询应返回 <code>null</code>。）</p>
<pre><code class="mysql">1.查询第二大的值的两种方式：
  a.使用基于not in的方式，把最大值排除出去，再选出第二大值(不需要考虑重复的问题)
  （查询非最大值的连接关键字效率（ 
   &#39;&lt;&#39;的效率最高
    not in 的效率其次
    &#39;&lt;&gt;&#39; 的效率最低
    ））
    语句如下：
  select Max(Salary) as SecondHighestSalary  from Employee 
where Salary &lt; (select Max(Salary) from Employee)


  b.使用order by + desc 降序，limit 1,1筛选出第二大
  使用 group by 去重比  distinct   更加好效率更高
  必须使用ifnull去确定为空的情况打印出为null
  ifnull(x，y)，若x不为空则返回x，否则返回y，这道题y=null
  limit x，y，找到对应的记录就停止
  语句如下：
    select 
    ifnull
    (
        (select Salary
        from Employee
        group by Salary
        order by Salary desc
        limit 1,1),
        null
    )as &#39;SecondHighestSalary&#39;

</code></pre>
<p>30、编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p>
<pre><code class="sql">创建存储过程，getNthHighestSalary(2)
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN 
  SET N=N-1;
  RETURN (
      # Write your MySQL query statement below.
     select ifnull((select salary from Employee group by salary
     order by salary DESC limit N,1),null)
  );
END


offset函数的出现
select distinct salary from employee
      order by salary desc limit P,1
# 上面等同于下面
select distinct salary from employee
      order by salary desc limit 1 offset P

</code></pre>
<p>31.编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。（相当于班级排名但是考虑出现并列的情况）</p>
<p>如下表</p>
<p>+—-+——-+<br>| Id | Score |<br>+—-+——-+<br>| 1  | 3.50  |<br>| 2  | 3.65  |<br>| 3  | 4.00  |<br>| 4  | 3.85  |<br>| 5  | 4.00  |<br>| 6  | 3.65  |<br>+—-+——-+</p>
<pre><code class="sql">1.不使用函数的情况下，其实是采用的表的自关联
select score,
(select count(distinct score) from scores where score &gt;= s.score ) as rank
from scores s order by score desc

select a.score as Score,
count(DISTINCT b.score) AS Rank # 统计b表符合条件的不重复的分数的数量作为排名
FROM scores a join scores b
where b.score &gt;= a.score # 条件是这个分数不小于我，因为a、b表数据相同，所以排名值最小是1
group by a.id # a表中每个数据都进行排名
order by a.score DESC # 最后按分数（跟排名一样）降序排列

2.使用函数进行排名
select score, 
       dense_rank() over(order by Score desc) as Rank
from Scores order by score desc;

</code></pre>
<p>31.编写一个 SQL 查询，查找所有至少连续出现三次的数字。</p>
<pre><code class="sql">如果题目是
编写一个 SQL 查询，查找所有至少出现三次的数字。
不考虑连续出现的情况
select total ConsecutiveNums from (select count(num) total from logs group by num) c where c.total&gt;=3 


考虑连续出现，需要将表拆分成3份
select l1.num ConsecutiveNums from logs l1,logs l2,logs l3
where l1.id=l2.id-1 and l2.id=l3.id-1 and l1.num=l2.num
and l2.num=l3.num group by l1.num

</code></pre>
<pre><code class="sql">SQLServer连接查询之Cross Apply和Outer Apply
相当于mysql的内连接inner join和外连接left join


</code></pre>
<p>32.编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p>
<pre><code class="sql">count(*)的效率大于count(字段名.)

select distinct a.Email from Person a, Person b where a.Email = b.Email and a.Id != b.Id

select  Email  from person group by email having count(*)&gt;1

</code></pre>
<ol start="33">
<li><strong>贷款状态的分布及占比</strong></li>
</ol>
<pre><code class="sql">由于表名太长，查询过程不方便，故先修改表名：
Rename table `loan payments data` to loan;

loan_id是客户的唯一贷款编号，先确认共有多少客户量，贷款编号是否有重复，代码如下：
  select distinct count(load_id) from loan;

结果显示共有500个客户，无重复的贷款编号。  
  Select loan_status AS &#39;贷款状态&#39;,count(loan_status) AS &#39;数量&#39;,
concat(round((count(loan_status)/(Select count(*) from loan )) *100,0),&#39;%&#39;) AS &#39;占比&#39;
from loan 
group by loan_status
order by &#39;占比&#39; DESC;

信贷行业中贷款逾期阶段有相应表达方式。通常，正常还款都属于M0阶段，M1=0-30天逾期，M2=31-60天，M3=61-90天，M4=90-120天，M5=121-150天，M6=151-180天，M6+&gt; 大于180天以上，M6+属于呆账。

本次分析的为子弹贷款的数据，放款金额及还款期限都小，故只查询M0-M3的占比情况，代码及结果如下：

(以下语句中需要注意的是past_due_days中正常还款客户是空字符(&#39;&#39;)，新手容易混淆成空值IS NULL)

select case when past_due_days =&#39;&#39; then &#39;M0&#39; 
when past_due_days &gt;=1 and past_due_days &lt;=30 then &#39;M1&#39; 
when past_due_days &gt;=31 and past_due_days &lt;=60 then &#39;M2&#39; ELSE &#39;M3&#39; 
END AS &#39;Default_stage&#39;,
count(*), 
concat(round((count(past_due_days)/(select count(*) from loan ))*100,2),&#39;%&#39;) AS &#39;PER&#39;  
from loan 
group by case when past_due_days =&#39;&#39;then &#39;M0&#39; 
when past_due_days &gt;=1 and past_due_days &lt;=30 then &#39;M1&#39; 
when past_due_days &gt;=31 and past_due_days &lt;=60 then &#39;M2&#39; 
ELSE &#39;M3&#39; END 
order by count(*) desc;

查询结果可知，paidoff正常还款的客户占比60%，collection及collection_paidoff统称为违约客户占比40%，单从数据上看，违约率还是比较高的。虽然违约率高达40%，但M1~M2占比较大，M3及以上的客户少，可看出通过后期的贷后管理，M1~M2的客户也会陆续进行还款。为节约贷后管理的成本，应在贷款中期调查批核阶段筛选掉高风险的客户，降低违约率。


</code></pre>
<h3 id="考试题目"><a href="#考试题目" class="headerlink" title="考试题目"></a>考试题目</h3><ul>
<li><em>求出每个部门的平均工资，及它的等级；</em></li>
</ul>
<pre><code class="sql">
-- 首先查询每个部门的平均工资
-- 在判断等级BETWEEN s.losal AND s.hisal
-- 最后在查出题目需要的条件
select t.dept_no,t.avg_sal,s.GRADE 
FROM (select avg(sal) as avg_sal,dept_no from emp GROUP BY dept_no) t 
 join salgrade s ON t.avg_sal BETWEEN s.losal AND s.hisal;  </code></pre>
<ul>
<li><em>求平均薪水最高的部门的部门编号</em></li>
</ul>
<pre><code class="sql">记住他
SELECT e.dept_no,avg(e.sal) as avg_sal
from emp e
GROUP BY e.dept_no
ORDER BY  avg_sal DESC
LIMIT 0,1
</code></pre>
<ul>
<li><em>查询出在（任何年份的）2月受聘的所有雇员；</em>  </li>
</ul>
<pre><code class="sql">
select * from EMP where substring(hire_date,6,2)=&#39;02&#39;

select * from emp where date_format(hire_date,&#39;%m&#39;)=&#39;02&#39;;

select * from EMP where MONTH(hire_date)=&#39;02&#39;

SELECT*from emp  where  hire_date like &quot;%-02-%&quot;
</code></pre>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小兔子乖乖</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="/www.dengjing520.cn/2019/11/02/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%A0%E9%A2%98/">www.dengjing520.cn/2019/11/02/sql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%A0%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="www.dengjing520.cn" target="_blank">Unique Craftsman</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tag1/">tag1</a><a class="post-meta__tags" href="/tags/tag2/">tag2</a><a class="post-meta__tags" href="/tags/tag3/">tag3</a></div><div class="post_share"><div class="social-share" data-image="/img/post/post5.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/pay/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/pay/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/pay/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/12/02/sql/03.%E7%B4%A2%E5%BC%95/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">索引（一）</div></div></a></div><div class="next-post pull-right"><a href="/2013/12/02/life/%E6%AF%8F%E5%A4%A9%E5%BF%85%E9%A1%BB%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/"><img class="next-cover" src="/img/post/post1.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">每天必须做的事情</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/06/02/sql/sql优化/" title="简单的SQL优化"><img class="cover" src="/img/post/post8.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-02</div><div class="title">简单的SQL优化</div></div></a></div><div><a href="/2020/05/02/redis/redis笔记 - 扩展/" title="Redis学习笔记"><img class="cover" src="/img/post/post4.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-02</div><div class="title">Redis学习笔记</div></div></a></div><div><a href="/2019/12/07/server/Tomcat优化 /" title="少许Tomcat基本优化点"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-07</div><div class="title">少许Tomcat基本优化点</div></div></a></div><div><a href="/2019/12/02/小的知识点/" title="编程日记"><img class="cover" src="/img/post/post.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">编程日记</div></div></a></div><div><a href="/2019/12/02/sql/01.事务/" title="数据库事务"><img class="cover" src="/img/post/post2.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">数据库事务</div></div></a></div><div><a href="/2019/12/02/life/live/写给自己的总结/" title="重新开始用心记录每一个遇到的问题"><img class="cover" src="/img/post/post7.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-02</div><div class="title">重新开始用心记录每一个遇到的问题</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(/img/post/post5.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小兔子乖乖</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="algolia-search"><div class="search-dialog__title" id="algolia-search-title">Algolia</div><div id="algolia-input-panel"><div id="algolia-search-input"></div></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-stats"></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/algolia.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script></div></body></html>